{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"ai/","title":"Artificial Intelligence","text":""},{"location":"blog/2025-06-01-why-event-driven-architecture-scales/","title":"Why Event-Driven Architecture Scales","text":"<p>Event-driven systems respond to events and messages asynchronously.</p>"},{"location":"blog/2025-06-01-why-event-driven-architecture-scales/#benefits","title":"Benefits","text":"<ul> <li>Loose coupling</li> <li>High scalability</li> <li>Real-time processing</li> </ul> <p>Commonly used in modern cloud-native applications.</p>"},{"location":"software-architecture/","title":"Software Architecture","text":""},{"location":"software-architecture/#cmu-sei-three-views","title":"CMU SEI Three Views","text":"<p>The CMU SEI (Software Engineering Institute) Three Views is a classic approach to documenting software architecture. The three views are:</p>"},{"location":"software-architecture/#1-module-view-decomposition-view","title":"1. Module View (Decomposition View)","text":"<ul> <li>What it shows: The static structure of the system in terms of modules (e.g., packages, classes, files).</li> <li>Purpose: Shows how the system is decomposed into implementation units and how these units relate to each other.</li> <li>Audience: Developers, maintainers.</li> <li>Details:      -Shows how the system is broken down into modules (e.g., packages, classes, files).<ul> <li>Focuses on code structure, encapsulation, and dependencies.</li> </ul> </li> <li>Example: A class diagram showing how classes are organized into packages.</li> </ul> <pre><code>classDiagram\n    class AuthModule\n    class UserModule\n    class OrderModule\n    class PaymentModule\n\n    AuthModule &lt;|-- UserModule : uses\n    UserModule &lt;|-- OrderModule : uses\n    OrderModule &lt;|-- PaymentModule : uses</code></pre>"},{"location":"software-architecture/#2-component-and-connector-view-cc-view","title":"2. Component-and-Connector View (C&amp;C View)","text":"<ul> <li>What it shows: The dynamic structure of the system as a set of components (units of computation) and connectors (interaction mechanisms).</li> <li>Purpose: Illustrates how runtime elements interact, such as processes, threads, data flows, and communication paths.</li> <li>Audience: System integrators, testers, performance engineers.</li> <li>Details: <ul> <li>Shows the runtime structure: components (processes, services) and connectors (communication, data flow).</li> <li>Focuses on how parts of the system interact at runtime.</li> </ul> </li> <li>Example: A diagram showing how services communicate over a network.</li> </ul> <pre><code>flowchart LR\n    ClientApp --&gt;|REST API| APIGateway\n    APIGateway --&gt;|gRPC| UserService\n    APIGateway --&gt;|gRPC| OrderService\n    OrderService --&gt;|Event| PaymentService\n    UserService --&gt;|DB| UserDB[(User Database)]\n    OrderService --&gt;|DB| OrderDB[(Order Database)]\n    PaymentService --&gt;|DB| PaymentDB[(Payment Database)]</code></pre>"},{"location":"software-architecture/#3-allocation-view","title":"3. Allocation View","text":"<ul> <li>What it shows: The mapping of software elements to the environment, such as hardware, file systems, or teams.</li> <li>Purpose: Shows how software is deployed, assigned to hardware, or mapped to development teams.</li> <li>Audience: System engineers, deployment engineers, project managers.</li> <li>Details: <ul> <li>Shows how software elements are mapped to hardware, file systems, or teams.</li> <li>Focuses on deployment, physical distribution, or team responsibility.</li> </ul> </li> <li>Example: A deployment diagram mapping software components to servers.</li> </ul> <pre><code>graph TD\n    subgraph AWS_Cloud[Cloud Provider]\n        subgraph VPC[Virtual Private Cloud]\n            subgraph Public_Subnet\n                LB[Load Balancer]\n            end\n            subgraph Private_Subnet\n                App1[App Server 1]\n                App2[App Server 2]\n                DB[(Database Cluster)]\n                Cache[(Redis Cache)]\n            end\n        end\n    end\n\n    Internet --&gt;|HTTPS| LB\n    LB --&gt; App1\n    LB --&gt; App2\n    App1 --&gt; DB\n    App2 --&gt; DB\n    App1 --&gt; Cache\n    App2 --&gt; Cache</code></pre>"},{"location":"software-architecture/#rup-41-views","title":"RUP 4+1 Views","text":"<p>RUP uses the \"4+1\" View Model, which consists of five views:</p>"},{"location":"software-architecture/#1-logical-view","title":"1. Logical View","text":"<ul> <li>What it shows: The object model of the design (e.g., class diagrams).</li> <li>Purpose: Addresses the functionality that the system provides to end-users.</li> <li>Audience: End-users, analysts, designers.</li> <li>Details: <ul> <li>Shows the object model of the design (e.g., class diagrams).</li> <li>Focuses on functionality provided to end-users.</li> </ul> </li> <li>Example: A class diagram showing how classes are organized into packages.</li> </ul> <pre><code>classDiagram\n    class User\n    class Order\n    class Product\n    class ShoppingCart\n\n    User \"1\" -- \"*\" Order : places\n    Order \"*\" -- \"*\" Product : contains\n    User \"1\" -- \"1\" ShoppingCart : owns\n    ShoppingCart \"*\" -- \"*\" Product : holds</code></pre>"},{"location":"software-architecture/#2-development-view-implementation-view","title":"2. Development View (Implementation View)","text":"<ul> <li>What it shows: The static organization of the software in the development environment (e.g., module structure).</li> <li>Purpose: Focuses on software management, configuration, and reuse.</li> <li>Audience: Programmers, software managers.</li> <li>Details: <ul> <li>Shows the static organization of the software in the development environment (e.g., module structure).</li> <li>Focuses on software management, configuration, and reuse.</li> </ul> </li> <li>Example: A class diagram showing how classes are organized into packages.</li> </ul> <pre><code>graph TD\n    subgraph src\n        subgraph controllers\n            UserController\n            OrderController\n        end\n        subgraph services\n            UserService\n            OrderService\n        end\n        subgraph models\n            UserModel\n            OrderModel\n            ProductModel\n        end\n        subgraph repositories\n            UserRepository\n            OrderRepository\n        end\n    end\n\n    UserController --&gt; UserService\n    OrderController --&gt; OrderService\n    UserService --&gt; UserRepository\n    OrderService --&gt; OrderRepository\n    UserService --&gt; UserModel\n    OrderService --&gt; OrderModel\n    OrderModel --&gt; ProductModel</code></pre>"},{"location":"software-architecture/#3-process-view","title":"3. Process View","text":"<ul> <li>What it shows: The dynamic aspects of the system, such as processes and their interactions.</li> <li>Purpose: Addresses concurrency, performance, and scalability.</li> <li>Audience: System integrators, performance engineers.</li> <li>Details: <ul> <li>Shows the dynamic aspects of the system, such as processes and their interactions.</li> <li>Focuses on concurrency, performance, and scalability.</li> </ul> </li> <li>Example: A class diagram showing how classes are organized into packages.</li> </ul> <pre><code>sequenceDiagram\n    participant User\n    participant WebApp\n    participant OrderService\n    participant PaymentGateway\n    participant InventoryService\n\n    User-&gt;&gt;WebApp: Place order\n    WebApp-&gt;&gt;OrderService: Create order\n    OrderService-&gt;&gt;InventoryService: Reserve items\n    OrderService-&gt;&gt;PaymentGateway: Process payment\n    PaymentGateway--&gt;&gt;OrderService: Payment confirmation\n    InventoryService--&gt;&gt;OrderService: Reservation confirmation\n    OrderService-&gt;&gt;WebApp: Order confirmation\n    WebApp-&gt;&gt;User: Show confirmation</code></pre>"},{"location":"software-architecture/#4-physical-view-deployment-view","title":"4. Physical View (Deployment View)","text":"<ul> <li>What it shows: The mapping of software onto hardware and the physical distribution of components.</li> <li>Purpose: Deals with system topology, communication, and deployment.</li> <li>Audience: System engineers, deployment engineers.</li> <li>Details: <ul> <li>Shows the mapping of software onto hardware and the physical distribution of components.</li> <li>Focuses on system topology, communication, and deployment.</li> </ul> </li> <li>Example: A class diagram showing how classes are organized into packages.</li> </ul> <pre><code>flowchart TD\n    subgraph Internet\n        UserClient\n    end\n    subgraph DMZ\n        LB[Load Balancer]\n    end\n    subgraph Web_Tier\n        Web1[Web Server 1]\n        Web2[Web Server 2]\n    end\n    subgraph App_Tier\n        App1[App Server 1]\n        App2[App Server 2]\n    end\n    subgraph Data_Tier\n        DB1[(Primary Database)]\n        DB2[(Replica Database)]\n        FS[(File Storage)]\n        Cache[(Redis Cache)]\n    end\n\n    UserClient --&gt; LB\n    LB --&gt; Web1\n    LB --&gt; Web2\n    Web1 --&gt; App1\n    Web2 --&gt; App2\n    App1 --&gt; DB1\n    App2 --&gt; DB1\n    DB1 --&gt; DB2\n    App1 --&gt; FS\n    App2 --&gt; FS\n    App1 --&gt; Cache\n    App2 --&gt; Cache </code></pre>"},{"location":"software-architecture/#5-use-case-view-1-view","title":"5. Use Case View (\"+1\" View)","text":"<ul> <li>What it shows: The scenarios and use cases that drive the architecture.</li> <li>Purpose: Ties all the other views together by showing how they support the required functionality.</li> <li>Audience: All stakeholders.</li> <li>Details: <ul> <li>Shows the scenarios and use cases that drive the architecture.</li> <li>Focuses on tying all the other views together by showing how they support the required functionality.</li> </ul> </li> <li>Example: A class diagram showing how classes are organized into packages.</li> </ul> <pre><code>flowchart TD\n    User((User)) --&gt;|Login| AuthSystem\n    User --&gt;|Browse| Catalog\n    User --&gt;|Add to Cart| ShoppingCart\n    User --&gt;|Checkout| OrderSystem\n    OrderSystem --&gt;|Payment| PaymentGateway\n    OrderSystem --&gt;|Inventory Check| InventorySystem</code></pre>"},{"location":"software-architecture/#summary-table","title":"Summary Table","text":"Framework View Name Focus/What it Shows CMU SEI Module Static structure (modules, packages) Component-and-Connector Runtime structure (components, connectors) Allocation Mapping to environment (hardware, teams) RUP (4+1) Logical Object model, functionality Development Implementation structure Process Dynamic behavior, concurrency Physical Deployment, hardware mapping Use Case Scenarios, requirements"},{"location":"software-architecture/design-principles/","title":"Design Principles","text":""},{"location":"software-architecture/design-principles/#key-principles","title":"Key Principles","text":"<ul> <li>Separation of Concerns</li> <li>Modularity</li> <li>Encapsulation</li> <li>Loose Coupling &amp; High Cohesion</li> <li>Scalability &amp; Resilience</li> </ul> <p>These principles ensure systems are flexible, testable, and maintainable.</p>"},{"location":"software-architecture/patterns/layered/","title":"Layered Architecture Pattern","text":"<p>Divides systems into layers (e.g., Presentation, Business, Data) with clear responsibilities.</p>"},{"location":"software-architecture/patterns/layered/#benefits","title":"Benefits","text":"<ul> <li>Separation of concerns</li> <li>Easy testing</li> <li>Simplicity</li> </ul>"},{"location":"software-architecture/patterns/layered/#limitations","title":"Limitations","text":"<ul> <li>Tight coupling across layers</li> <li>Performance overhead</li> </ul>"},{"location":"software-architecture/patterns/microservices/","title":"Microservices Pattern","text":"<p>Breaks applications into small, independent services that communicate via APIs.</p>"},{"location":"software-architecture/patterns/microservices/#benefits","title":"Benefits","text":"<ul> <li>Independent deployment</li> <li>Technology heterogeneity</li> <li>Fault isolation</li> </ul>"},{"location":"software-architecture/patterns/microservices/#challenges","title":"Challenges","text":"<ul> <li>Complexity in orchestration</li> <li>Data consistency</li> </ul>"}]}